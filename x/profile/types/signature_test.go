package types_test

import (
	"testing"

	"github.com/pkg/errors"
	"github.com/stretchr/testify/require"
	spntypes "github.com/tendermint/spn/pkg/types"
	"github.com/tendermint/spn/testutil/sample"
	"github.com/tendermint/spn/x/profile/types"
	"github.com/tendermint/tendermint/crypto/ed25519"
)

func TestCheckValidatorSignature(t *testing.T) {
	var (
		mnemonic      = "cruel better below expect save rebuild judge drift basket stool paddle final gate behind dismiss dad stove uniform gift mean hat kit idea paddle"
		privKey       = ed25519.GenPrivKeyFromSecret([]byte(mnemonic))
		pubKey        = privKey.PubKey().Bytes()
		invalidPubKey = ed25519.GenPrivKey().PubKey().Bytes()
	)
	type args struct {
		signature  []byte
		consPubKey []byte
		chainID    string
		nonce      uint64
	}
	tests := []struct {
		name string
		args args
		err  error
	}{
		{
			name: "valid check",
			args: args{
				signature:  []byte{0x99, 0x37, 0x45, 0x2d, 0x4a, 0x60, 0xeb, 0x6e, 0xbe, 0x46, 0x2c, 0x41, 0xc9, 0x8, 0xe9, 0x0, 0x57, 0x32, 0xce, 0xb6, 0xc3, 0x6e, 0xe3, 0x46, 0x90, 0x9, 0x0, 0x9d, 0xa3, 0x61, 0x93, 0xb9, 0xcc, 0x14, 0xa7, 0xa5, 0x12, 0x7, 0xc7, 0x8, 0xe2, 0xee, 0x6b, 0xb, 0x6c, 0xd5, 0xee, 0x83, 0xea, 0xbf, 0xc, 0x49, 0xc2, 0x95, 0xee, 0x1e, 0x8d, 0x25, 0xde, 0x7b, 0x37, 0x13, 0xac, 0xa},
				consPubKey: pubKey,
				chainID:    "spn-1",
				nonce:      10,
			},
		},
		{
			name: "without chain id",
			args: args{
				signature:  []byte{0x79, 0xa, 0x37, 0xd2, 0xa5, 0x49, 0xbb, 0x74, 0x56, 0x30, 0x7, 0xdf, 0x52, 0x83, 0x9f, 0x1e, 0xcf, 0x90, 0x2d, 0x22, 0x9d, 0x3, 0x9e, 0x9b, 0x48, 0xde, 0xdc, 0x64, 0xf2, 0x90, 0x58, 0xc8, 0xd8, 0xaa, 0xaf, 0xd3, 0xa2, 0xa5, 0x37, 0x67, 0x1c, 0x4d, 0x41, 0x41, 0xe7, 0xae, 0xff, 0x11, 0x8d, 0x5b, 0xfd, 0xca, 0x95, 0xa0, 0x82, 0xa7, 0x8e, 0x83, 0x45, 0x94, 0x7f, 0xda, 0xa, 0x5},
				consPubKey: pubKey,
				chainID:    "",
				nonce:      10,
			},
		},
		{
			name: "zero nonce",
			args: args{
				signature:  []byte{0xa6, 0x84, 0x82, 0x38, 0x71, 0x40, 0xbc, 0xb1, 0x83, 0x22, 0x59, 0x96, 0xd8, 0x4, 0xd2, 0x9c, 0x60, 0xe, 0x83, 0xb3, 0xee, 0xf7, 0xed, 0xf9, 0xbf, 0x49, 0x0, 0xe1, 0xb6, 0x10, 0x7f, 0xcd, 0xbb, 0x53, 0x51, 0xf4, 0xab, 0xdb, 0x8a, 0x30, 0xf1, 0x99, 0x68, 0xad, 0xd1, 0x99, 0xb7, 0x2f, 0xd9, 0xb0, 0xac, 0xed, 0xc6, 0x7e, 0xe6, 0x91, 0x91, 0xf, 0xc9, 0x80, 0x47, 0x5b, 0x7d, 0x3},
				consPubKey: pubKey,
				chainID:    "spn-1",
				nonce:      0,
			},
		},
		{
			name: "invalid signature",
			args: args{
				signature:  sample.Bytes(10),
				consPubKey: pubKey,
				chainID:    "spn-1",
				nonce:      0,
			},
			err: errors.New("invalid signature"),
		},
		{
			name: "invalid pub key",
			args: args{
				signature:  []byte{0x99, 0x37, 0x45, 0x2d, 0x4a, 0x60, 0xeb, 0x6e, 0xbe, 0x46, 0x2c, 0x41, 0xc9, 0x8, 0xe9, 0x0, 0x57, 0x32, 0xce, 0xb6, 0xc3, 0x6e, 0xe3, 0x46, 0x90, 0x9, 0x0, 0x9d, 0xa3, 0x61, 0x93, 0xb9, 0xcc, 0x14, 0xa7, 0xa5, 0x12, 0x7, 0xc7, 0x8, 0xe2, 0xee, 0x6b, 0xb, 0x6c, 0xd5, 0xee, 0x83, 0xea, 0xbf, 0xc, 0x49, 0xc2, 0x95, 0xee, 0x1e, 0x8d, 0x25, 0xde, 0x7b, 0x37, 0x13, 0xac, 0xa},
				consPubKey: sample.Bytes(10),
				chainID:    "spn-1",
				nonce:      0,
			},
			err: errors.New("ed25519: bad public key length: 10"),
		},
		{
			name: "invalid pub key",
			args: args{
				signature:  []byte{0x99, 0x37, 0x45, 0x2d, 0x4a, 0x60, 0xeb, 0x6e, 0xbe, 0x46, 0x2c, 0x41, 0xc9, 0x8, 0xe9, 0x0, 0x57, 0x32, 0xce, 0xb6, 0xc3, 0x6e, 0xe3, 0x46, 0x90, 0x9, 0x0, 0x9d, 0xa3, 0x61, 0x93, 0xb9, 0xcc, 0x14, 0xa7, 0xa5, 0x12, 0x7, 0xc7, 0x8, 0xe2, 0xee, 0x6b, 0xb, 0x6c, 0xd5, 0xee, 0x83, 0xea, 0xbf, 0xc, 0x49, 0xc2, 0x95, 0xee, 0x1e, 0x8d, 0x25, 0xde, 0x7b, 0x37, 0x13, 0xac, 0xa},
				consPubKey: invalidPubKey,
				chainID:    "spn-1",
				nonce:      0,
			},
			err: errors.New("invalid signature"),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := types.CheckValidatorSignature(tt.args.signature, tt.args.consPubKey, tt.args.chainID, tt.args.nonce)
			if tt.err != nil {
				require.Error(t, err, tt.err)
				require.Equal(t, tt.err.Error(), err.Error())
				return
			}
			require.NoError(t, err)
		})
	}
}

func TestSignValidatorMessage(t *testing.T) {
	mnemonic := "cruel better below expect save rebuild judge drift basket stool paddle final gate behind dismiss dad stove uniform gift mean hat kit idea paddle"
	tests := []struct {
		name    string
		chainID string
		nonce   uint64
		want    []byte
		err     error
	}{
		{
			name:    "valida sign",
			chainID: "spn-1",
			nonce:   10,
			want:    []byte{0x99, 0x37, 0x45, 0x2d, 0x4a, 0x60, 0xeb, 0x6e, 0xbe, 0x46, 0x2c, 0x41, 0xc9, 0x8, 0xe9, 0x0, 0x57, 0x32, 0xce, 0xb6, 0xc3, 0x6e, 0xe3, 0x46, 0x90, 0x9, 0x0, 0x9d, 0xa3, 0x61, 0x93, 0xb9, 0xcc, 0x14, 0xa7, 0xa5, 0x12, 0x7, 0xc7, 0x8, 0xe2, 0xee, 0x6b, 0xb, 0x6c, 0xd5, 0xee, 0x83, 0xea, 0xbf, 0xc, 0x49, 0xc2, 0x95, 0xee, 0x1e, 0x8d, 0x25, 0xde, 0x7b, 0x37, 0x13, 0xac, 0xa},
		},
		{
			name:    "without chain id",
			chainID: "",
			nonce:   10,
			want:    []byte{0x79, 0xa, 0x37, 0xd2, 0xa5, 0x49, 0xbb, 0x74, 0x56, 0x30, 0x7, 0xdf, 0x52, 0x83, 0x9f, 0x1e, 0xcf, 0x90, 0x2d, 0x22, 0x9d, 0x3, 0x9e, 0x9b, 0x48, 0xde, 0xdc, 0x64, 0xf2, 0x90, 0x58, 0xc8, 0xd8, 0xaa, 0xaf, 0xd3, 0xa2, 0xa5, 0x37, 0x67, 0x1c, 0x4d, 0x41, 0x41, 0xe7, 0xae, 0xff, 0x11, 0x8d, 0x5b, 0xfd, 0xca, 0x95, 0xa0, 0x82, 0xa7, 0x8e, 0x83, 0x45, 0x94, 0x7f, 0xda, 0xa, 0x5},
		},
		{
			name:    "zero nonce",
			chainID: "spn-1",
			nonce:   0,
			want:    []byte{0xa6, 0x84, 0x82, 0x38, 0x71, 0x40, 0xbc, 0xb1, 0x83, 0x22, 0x59, 0x96, 0xd8, 0x4, 0xd2, 0x9c, 0x60, 0xe, 0x83, 0xb3, 0xee, 0xf7, 0xed, 0xf9, 0xbf, 0x49, 0x0, 0xe1, 0xb6, 0x10, 0x7f, 0xcd, 0xbb, 0x53, 0x51, 0xf4, 0xab, 0xdb, 0x8a, 0x30, 0xf1, 0x99, 0x68, 0xad, 0xd1, 0x99, 0xb7, 0x2f, 0xd9, 0xb0, 0xac, 0xed, 0xc6, 0x7e, 0xe6, 0x91, 0x91, 0xf, 0xc9, 0x80, 0x47, 0x5b, 0x7d, 0x3},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := types.SignValidatorMessage(mnemonic, tt.chainID, tt.nonce)
			if tt.err != nil {
				require.ErrorIs(t, err, tt.err)
				return
			}
			require.NoError(t, err)
			require.Equal(t, tt.want, got)
			privKey := ed25519.GenPrivKeyFromSecret([]byte(mnemonic))
			errValid := types.CheckValidatorSignature(
				got,
				privKey.PubKey().Bytes(),
				tt.chainID,
				tt.nonce,
			)
			require.NoError(t, errValid)
		})
	}
}

func Test_createSignMessage(t *testing.T) {
	tests := []struct {
		name    string
		chainID string
		nonce   uint64
		want    []byte
	}{
		{
			name:    "with nonce and chain id",
			chainID: "spn-1",
			nonce:   10,
			want:    []byte{0x53, 0x74, 0x61, 0x72, 0x70, 0x6f, 0x72, 0x74, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2d, 0x4d, 0x73, 0x67, 0x53, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x2f, 0x73, 0x70, 0x6e, 0x2d, 0x31, 0x2f},
		},
		{
			name:    "zero nonce",
			chainID: "spn-1",
			want:    []byte{0x53, 0x74, 0x61, 0x72, 0x70, 0x6f, 0x72, 0x74, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2d, 0x4d, 0x73, 0x67, 0x53, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2f, 0x73, 0x70, 0x6e, 0x2d, 0x31, 0x2f},
		},
		{
			name:  "without chain id",
			nonce: 10,
			want:  []byte{0x53, 0x74, 0x61, 0x72, 0x70, 0x6f, 0x72, 0x74, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2d, 0x4d, 0x73, 0x67, 0x53, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x73, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa, 0x2f, 0x2f},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := spntypes.CreateSignMessage(tt.nonce)
			require.Equal(t, tt.want, got)
		})
	}
}

func Test_uintBytes(t *testing.T) {
	tests := []struct {
		name string
		v    uint64
		want []byte
	}{
		{name: "zero value", v: 0, want: []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}},
		{name: "one value", v: 1, want: []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}},
		{name: "teen value", v: 100, want: []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := spntypes.UintBytes(tt.v)
			require.Equal(t, tt.want, got)
		})
	}
}
